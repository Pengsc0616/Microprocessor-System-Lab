.data
	result: .word	0
	max_size:	.word	0
.text
	m:	.word	0x5E
	n:	.word	0x60

GCD:
		/*TODO: Implement your GCD function */
	ldr r2, [sp]	//r2=m
	ldr r3, [sp,#4] //r3=n
	pop	{r1,r0}		//r0=m, r1=n
	long_loop:
		cmp r2, #0		//if(m==0) return n
		beq return_n
		cmp	r3, #0		//if(n==0) return m;
		beq	return_m
		movs r2, r2>>1
		cmp r2, #0
		beq maybe_also	//if(m%2==0) or if(m%2==0 && n%2==0)
		movs r3, r3>>1
		cmp r3, #0
		beq	only_n_isEven //if(n%2==0) return GCD(m, n>>1)

		//else return GCD(abs(m-n),min(m,n))

	return_n:
	return_m:
	maybe_also:
	only_n_isEven:
	BX LR
main:
	/* r0 = m, r1 = n */
	ldr	ro, m
	ldr r1, n
	push	{r0,r1}
	BL GCD
	/* get return val and store into result */
/*
int GCD(int a, int b)
{
if(a==0) return b;
if(b==0) return a;
if(a%2==0 && b%2==0) return 2*GCD(a>>1,b>>1)
else if(a%2==0) return GCD(a>>1, b)
else if(b%2==0) return GCD(a, b>>1)
else return GCD(abs(a-b),min(a,b))
}
/*

/*
	MOVS	RO, #1
	MOVS	R1, #2
	PUSH	{R0, R1}
	LDR	R2, [sp]
	LDR	R3, [sp, #4]
	POP	{R0, R1}
*/
